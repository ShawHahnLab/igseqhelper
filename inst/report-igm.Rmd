# IgM+ Specimens - Germline allele discovery with IgDiscover

```{r}
SEGMENTS <- c("V", "D", "J")
names(SEGMENTS) <- SEGMENTS

# Specific to how we're running IgDiscover
CHAINTYPES <- c(mu = "heavy.mu", lambda = "light.lambda", kappa = "light.kappa")

# Load nested lists of final results from an IgDiscover output directory.
load_igdiscover_final <- function(dirpath) {
  data <- within(list(), {
    database <- lapply(SEGMENTS, function(segment) {
      dnar::read.fa(
        file.path(dirpath, "final/database", paste0(segment, ".fasta")))
    })
    stats = list(
      filtered = rjson::fromJSON(file = file.path("final/stats/filtered.json")),
      assigned = rjson::fromJSON(file = file.path("final/stats/assignd.json")))
  })
  data
}

# Given a named list of FASTA name/seq entries, make a grid of which sequences
# are represented in which FASTAs, with 0 for absent and 1 for present.
gather_seq_overlaps <- function(seq_sets) {
  seqs_all <- sort(unique(unlist(seq_sets)))
  mat <- do.call(cbind, lapply(names(seq_sets), function(samp) {
    seqs_all %in% seq_sets[[samp]]
  }))
  rownames(mat) <- seqs_all
  colnames(mat) <- names(seq_sets)
  as.data.frame(mat + 0)
}

# Load  a complete set of IgDiscover results with our output directory structure
# (chain_type/sample/...)
load_all_igdiscover_results <- function(dirpath) {
  igdiscover_results <- list()
  lapply(CHAINTYPES, function(chaintype) {
    dirs <- list.dirs(file.path(dirpath, chaintype), recursive=FALSE)
    names(dirs) <- basename(dirs)
    lapply(dirs, function(dirpath) {
      load_igdiscover_final(dirpath)
    })
  })
}

# Load the initial V/D/J used for each chain type for IgDiscover.
load_igdiscover_reference <- function(dirpath) {
  lapply(CHAINTYPES, function(chaintype) {
    lapply(SEGMENTS, function(segment) {
      dnar::read.fa(file.path(dirpath, chaintype, paste0(segment, ".fasta")))
    })
  })
}

igdiscover_results <- load_all_igdiscover_results(file.path(ROOT, "igdiscover"))
igdiscover_reference <- load_igdiscover_reference(file.path(ROOT, "igdiscover"))

overlaps <- list(
  mu = lapply(SEGMENTS, function(segment) {
    seq_sets <- lapply(igdiscover_results$mu, function(obj) obj$database[[segment]]$seq)
    seq_sets <- c(list(reference=igdiscover_reference$mu[[segment]]$seq), seq_sets)
    gather_seq_overlaps(seq_sets)
  }),
  kappa = lapply(SEGMENTS, function(segment) {
    seq_sets <- lapply(igdiscover_results$kappa, function(obj) obj$database[[segment]]$seq)
    seq_sets <- c(list(reference=igdiscover_reference$kappa[[segment]]$seq), seq_sets)
    gather_seq_overlaps(seq_sets)
  }),
  lambda = lapply(SEGMENTS, function(segment) {
    seq_sets <- lapply(igdiscover_results$lambda, function(obj) obj$database[[segment]]$seq)
    seq_sets <- c(list(reference=igdiscover_reference$lambda[[segment]]$seq), seq_sets)
    gather_seq_overlaps(seq_sets)
  })
)
```

## IgDiscover - Results Summary by Chain Type

The below plots summarize the number and overlap of alleles detected in each of 
the heavy (mu) chain samples compared with the starting reference database. 
Each horizontal bar shows the total number of sequences in that sample.  Each
vertical bar is a particular combination of samples, with height displaying the
number of sequences occuring in that combination.

### Heavy Chain - Mu - V Segment

```{r fig.height=4}
UpSetR::upset(overlaps$mu$V, order.by = "freq")
```

### Heavy Chain - Mu - D Segment

```{r fig.height=4}
UpSetR::upset(overlaps$mu$D, order.by = "freq")
```

### Heavy Chain - Mu - J Segment

```{r fig.height=4}
UpSetR::upset(overlaps$mu$J, order.by = "freq")
```

### Light Chain - Kappa - V Segment

```{r fig.height=4}
UpSetR::upset(overlaps$kappa$V, order.by = "freq")
```

### Light Chain - Kappa - J Segment

```{r fig.height=4}
UpSetR::upset(overlaps$kappa$J, order.by = "freq")
```

### Light Chain - Lambda - V Segment

```{r fig.height=4}
UpSetR::upset(overlaps$lambda$V, order.by = "freq")
```

### Light Chain - Lambda - J Segment

```{r fig.height=4}
UpSetR::upset(overlaps$lambda$J, order.by = "freq")
```

## IgDiscover - Results by Specimen

Below are read counts through each stage of IgDiscover filtering for each 
sample.  The input is as specified in the Grouping by Specimen section above. 
According to the paper around 400,000 input reads should be sufficient.

```{r}
# TODO replace this mess and embed within igdiscover_results above
with(NULL, {
  filepaths <- grep(
    "final",
    list.files(file.path(ROOT, "igdiscover"), full.names = TRUE, recursive = TRUE, pattern = "filtered\\.json"),
    value = TRUE)
  # ugh
  x <- sub('.*igdiscover/', "", filepaths)
  md <- lapply(strsplit(x, "/"), function(vec) c(Chain=sub("\\..*", "", vec[1]), Type=sub(".*\\.", "", vec[1]), Specimen=vec[2]))
  cts <- do.call(rbind, lapply(seq_along(filepaths), function(i) {
    as.data.frame(c(md[[i]], rjson::fromJSON(file = filepaths[i])))
  }))
  abbrs <- c(
    Chain = "Chain", Type = "Type", Specimen = "Specimen",
    total = "total", has_vj_assignment = "has_vj", has_no_stop = "no_stop",
    good_v_evalue = "good_v_ev", good_v_coverage = "good_v_cov",
    good_j_coverage = "good_j_cov", has_cdr3 = "has_cdr3")
  colnames(cts) <- abbrs[colnames(cts)]
  kableExtra::kable_styling(drawtab(cts), font_size = 6)
})

```
